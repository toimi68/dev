bit.do/poles-v c'est pour recup√©rer les fichiers drive
programme :  

1/ R√©vision PHP OO:

Visibilit√© - Autoload - Namespace - Interfase

2/ MVC

SYMFONY :

INTRO: qu'est-ce que Symfony?
ETAPE 1 : Installation de SF 3.4 LTS : Long Time Support
ETAPE 2 : Les bundles
ETAPE 3 : Les routes et les controllers
ETAPE 4 : Cr√©er la boutique sur SF
ETAPE 5 : TWIG (moteur de template)
ETAPE 6 : Les assets
ETAPE 7 : Les entit√©s
ETAPE 8 : DOCTRINE
ETAPE 9 : Les formulaires
ETAPE 10 : Validation des donn√©es
ETAPE 11 : Association Mapping
ETAPE 12 : S√©curit√© et utilisateur
ETAPE 13 : Installation et boutique sur SF 4.3
BONUS : mise en prod
BONUS : Formulaire de contact

-----------------------------------------------------------
INTRO : Qu'est-ce que Symfony 
-----------------------------------------------------------

1/ Quel int√©r√™t d'utiliser un Framework 
    A. Une organisation optimis√©e
    B. Fonctionnalit√©s communes √† tous les projets(ex:si on doit intervenir dans un projet,il y a les modules utilisateur)
    C. Service disponibles (Routing, S√©curit√©, BDD,Moteur de template,formulaire...)
    D. Communaut√©



2/ Le choix du Framework
    A. Propre Framework (p√©dagogie)
    B. Les framework fullstack (Symfony, Zend, Laravel, Cake ...)
    C. Les mini Framework (Silex, Slim, CodeIgniter, Lumen ...)


3/ Symfony

    ->Framework Fran√ßais cr√©√© par sensiolabs
    ->versions:
    LTS (Long Time Support) : 
        v2.8
        v3.4 : 2.8  plus souple (moins rigide), avec des Fonctionnalit√©s
        v4.4 : 3.4 BundleLess, Flex, Encore (webpack), Maker, PHP7.1

-----------------------------------------------------------------------------------
ETAPE 1 : Installation de SF 3.4
Sommaire :
1 / Installer Composer
2 / Installer SF3.4
3 / Arborescence des dossiers et fichiers
4 / Lancement de l'application 
------------------------------------------------------------------------------------- 

1 / Installer Composer

Composer est un outils de d√©pendance.
Il permet de t√©l√©charger et de mettre √† jour tous les outils (services, composants, d√©pendances) dont on a besoin.

    - T√©l√©charger : https://getcomposer.org/download/
    composer-Setup.exe

    - Installer : Suivre les √©tapes (en d√©cochant)

2 / Installer SF3. 4

    - Dans le dossier Symfony
    - MAJ + clic-droit : Ouvrir une fen√™tre powershell ici

    <cmd>
    composer create-project symfony/framework-standard-edition test

    ==> A ce stade, un dossier test a √©t√© cr√©√©. C'est un nouveau projet SF.

3 / Arborescence des dossiers et fichiers

    - app/  : contient toue la configuration de l'app (BDD, s√©curit√©, routes...)
    - bin/  : les √©x√©cutable de l'app (de SF)
    - src/  : le dossier dans lequel nous allons coder notre MCV
    - var/  : les fichiers √©crits par SF au fur et √† mesure (cache,logs)
    - tests/ : Les tests unitaires.
    - web/  : Repertoire WEB (app.php ou app_dev.php,(√©quivalent de index) img/css/js/fonts)
    - vendor/ : Le coeur de SF (les fichiers cod√©s par les sensio Labs)

    - composer.json : Contient la liste de toutes les d√©pendances dont on a besoin. "d√©pendances = les fichiers cr√©er par sension labs et dont on va s'en servir"

4 / Lancement de l'application

    - M√©thode 1 :
    localhost/Back/Symfony/Test/web/app.php
    localhost/Back/Symfony/Test/web/app_dev.php


    - M√©thode 2 :
    On va dans le dossier test/
    <cmd>
    php bin/console server:run [ou √©crire sur 'localhost:8000']

    -Diff√©rence entre mode prov et dev:

    localhost/Symfony/Test/web/toto
    localhost:8000/toto

    ==> A ce stade notre application affiche la page de bienvenue. Cela signifie que tout va bien.

----------------------------------------------------------------------------------
ETAPE 2 : Les bundles
Sommaire:
1 / Le concept des bundles
2 / Cr√©ation de notre premier Bundle
----------------------------------------------------------------------------------

1 / Le concept des Bundles

    - Les bundles sont des briques de notre applications.

    UserBundle : 
    UserController (C)
    UserModel (M)
    View : inscription/connexion/profil...

    Avec la nouvelle version de SF(4), on consid√®re qu'il est pr√©f√©reable de cr√©er un seul Bundle (AppBundle).

2 / Cr√©ation de notre premier Bundle

    On va cr√©er un Bundle : (namespace)POLES/TestBundle(nom entreprise)

    <cmd> (ou terminal VisualCode)
    php bin/console generate:bundle

    ->Yes
    ->POLES/TestBundle
    ->POLESTestBundle
    ->src/
    ->annotation

    ==> Notre Bundle a √©t√© cr√©e, mais il faut l'enregistrer.

    <code>composer.json (aller dans le fichier et rajouter ligne de code)
     "psr-4": {
            "AppBundle\\": "src/AppBundle",
            "POLES\\": "src/POLES"
     },

     -Mise √† jour de l'app
     <cmd>
     composer update

     ===> Notre Bundle existe dans src/POLES/TestBundle
     Il est compos√© de 4 dossiers:
        - Controller : Les controllers du bundle
        - DependencyInjection : Injection de d√©pendances.
        - Ressources : Vues et Routes (YML) et eventuellement JS
        - Test : Test li√©es aux fonctionnalit√© du Bundle.

    ===> A ce stade le Bundle est fonctionnel, mais il y a une petite erreur qu'on va corriger.

    - src/POLES/TestBundle/Controller/DefaultController.php

    <code>
     return $this->render('POLESTestBundle:Default:index.html.twig');
     Devient :
     return $this->render('@POLESTest/Default/index.html.twig');

     ===> A ce stade, la page d'accueil affiche "Hello World".

----------------------------------------------------------------------------------
ETAPE 3 : Les routes et les controllers
Sommaire :

1 / Cr√©ation de routes
2 / L'objet Request
3 / L'objet response
4 / Redirection
5 / Message

twig est un moteur de template (fichier html) qui va nous permettre de mettre du php dans nos vue de mani√®re plus simple

il faut aller ds le dossier hola.html.twig dans 
 srx/POLES/TestBundle/Resources/views/Default/hola.twig et ecrire ce qu'on veut afficher ds la page puis faire le test
 test : localhost:8000/hola/Yakine/
----------------------------------------------------------------------------------------------------------------------------

1 / Cr√©ation de routes
    ("/") -> route simple homepage
    ("/bonjour/") -> route echo (erreur)
    ("/bonjour2/") -> route response
    ("hello/{prenom}") -> route response + param UserBundle
    ("/hola/{prenom}") -> route render de vue(html.twig) + param URL
    ("/ciao/{prenom}/{age}") -> route render de vue + 2 params URL
    ("redirect/") -> route avec redirection (RedirectResponse)
    ("/redirect2") -> route avec redirection (redirectToRoute())
    ("/message/") -> route avec redirect et message en session 

2 / L'objet Request
    <code>
    use Symfony\Component\HttpFoundation\Request;

    Correspond √† la partie requete de la requete HttpFoundation

    <ex code>
    $session = $request -> getSession();
    -> r√©cup√®re la session ($_SESSION)

    Autres exemples:
    
    $session -> set('prenom','Yakine');
    echo $session ->get('prenom');

    Autre m√©thode :
    $request -> session -> set('prenom', 'Yakine');

    Autres utilit√© de $request :

    index.php?argument_url=toto
    $request -> query -> get('argument_url'); // permet de r√©cup√©rer le champs de l'URL
    $request -> request -> get('champs_form'); // permet de r√©cup√©rer le champs du formulaire
    $request -> cookies -> get('cookie'); // 
    $request -> server -> get('DOCUMENT_ROOT'); // permet de r√©cup√©rer les info du serveur
    
    /exemple/ {prenom}
    /exemple/?prenom=yakine

3 / L'objet Response

    -Correspond √† la partie r√©ponse d'une requ√™te HttP.

    <code>
    use Symfony\Component\HttpFoundation\Response;

    Toute action (fonction) doit avec une r√©ponse.

    return new Response ('toto');

    m√™me la fonction render est une r√©ponse.

    return $this-> render();
    return $this-> getTemplating() -> renderResponse();

4 / Redirection

    <code>premiere m√©thode :
    use Symfony\Component\HttpFoundation\RedirectResponse;

    cf route "/redirect/" et "/redirect2"

    /!\ √† ce stade toutes nos routes doivent avoir un name

5 / Message

    <code>
    $session ->getFlashBag() -> add();

    ->permet d'enregistrer des messages qui seront disponible dans d'autres pages (messages de f√©licitations, ou d'erreur).
    
    ->app.session : Qui nous permet en Twig de r√©cup√©rer les infos en session.
    ->app.user : Qui nous permet en Twig de r√©cup√©rer les infos de l'utilisateur actuellement connect√©


------------------------------------------------------------------------------------------------------------------------------

ETAPE 4 : Cr√©er la Boutique sur SF 3.4

Sommaire :
1 / Cr√©ation du projet
2 / R√©organiser le AppBundle
3 / Cr√©ation des premi√®re route
------------------------------------------------------------------------------------------------------------------------------

1 / Cr√©ation du projet

    - Dans le dossier Symfony
    <cmd>
    composer create-project symfony/framework-standard-edition Boutiques3
    cd Boutique3
    php bin/console server:run
    
    Test : localhost:8001

2 / R√©organiser le AppBundle

     localhost/              -> index.html.twig
     localhost/categorie/pull-> index.html.twig
     localhost/produit/12    ->show.html.twig

Admin Controller :

localhost/admin/produit/list/
        ->Admin/list_produit.html.twig
        ->'Je suis dans la page qui liste les produits'

localhost/admin/produit/add/
        ->Admin/form_produit.html.twig
        ->'Je suis dans le formulaire produit'

    -> Cr√©ation de nos controllers:
        AdminController
        MembreController
        CommandeController
        ProduitController
        --
        SecurityController (pour plus tard si besoin)
        BaseController
    
    -> Cr√©ation de nos Vues
        Admin/ (list_produit, form_produit etc...)
        Membre/ (connexion, inscription, profil...)
        Commande/ (panier, transport, livraison, paiement...)
        Produit/ (home, categorie, boutique, fiche_produit...)

3/ Cr√©ation des premi√®res routes

    -> ProduitController : "/", "/produit/{id}/" etc...
    ->AdminController : "/admin/produit/", "/admin/membre/" etc...

------------------------------------------------------------------------------------------------------------------------

ETAPE 5 : TWIG (moteur de template)
Sommaire : 
1 / Cr√©ation du layout
2/ l'Heritage Twig
3/ Modification de nos Vues
4/ Documentation Twig
------------------------------------------------------------------------------------------------------------------------
    TWIG est le moteur de tempalte de Symfony. Un moteur de tempalte (tpl, smarty, twig, blade ...) permet d'afficher du php dans les vues HTML de mani√®re plus simple.

    exemple :
    <?= $membre['prenom'] ?>
    {{ membre.prenom }}

1/ Cr√©ation du layout

   Chemin :  Boutique3/app/Resources/views/layout.html.twig

    Un Layout est une structure de page, dans laquelle on peut ajouter des √©l√©ments/ du contenu.
    Le concept des layout permet d'avoir plusieurs structures de pages dans notre site (ex: front vs backoffice).

    <!-- A faire : Cr√©ation des pages connexion, inscription et profil : 
    
    Dans MembreController : 
        route("/inscription/", name="inscription")
        render de Membre/inscription.html.twig
    
        route("/connexion/", name="connexion")
        render de Membre/connexion.html.twig
    
        route("/profil/", name="profil")
        render de Membre/profil.html.twig
    
    2/ Cr√©er les vues
        Membre/inscription.html.twig
        Membre/connexion.html.twig
        Membre/profil.html.twig
        
        Attention : ces vues,h√©ritent de layout.html.twig
    
    3/ Ajouter les nouvelles pages dans le menu de notre SecurityController
    
        -Dans layout.html.twig
    
        path('inscription')
        path('connexion')
        path('profil')
         -->

2/ L'H√©ritage Twig

        Avec Twig on parle d'h√©ritage. Cel√† signifie que nos vues h√©ritent (extends) d'un layout , et peuvent contenir de l'HTML √† l'int√©rieur des block disponible (cr√©es dans le layout).

====> De mani√®re g√©n√©rale, il faut voir le fonctionneement de Twig et de la m√©thode render comme un chargement du contenu de mani√®re "empil√©e" (analogie de la poup√©e russe). 
Render temporise (m√©moire tempon) le contenu, et affiche en m√™me temps le Layout, la vue et les params.

3/ Modification de nos vues

    <code>
        {% extends 'layout.html.twig' %}
        {% block content %}
        Contenu HTML de la pages
        {% endblock %}

    /!\ ATTENTION : Quand on utilise l'h√©ritage Twig, nos vues ne peuvent contenir de l'HTML qu'a l'int√©rieur des blocks pr√©vus pour

4/ Documentation Twig

        http://twig.symfony.com/doc/2.x/

====> A ce stade, notre app permet d'afficher les pages accueil, inscription, connexion, profil, boutique, produit, cat√©gorie, gestion membre, gestion produit et gestion commande.

====> Par contre nous ne sommes pas encore en mesure d'√©changer avec ma BDD (ajouter un contenu, recup√©rer un contenu), il faut voir les entity et Doctrine.

-----------------------------------------------------------
ETAPE 6 : ASSETS
-----------------------------------------------------------

Sommaire :
1/ Modification du fichier composer.json
2/ Mise √† jour de l'app.
3/ Dossier Web (photo, css / js...)
4/ Modification des vues.
-----------------------------------------------------------

    - Le composant Assset de SF nous permet de g√©rer les ressources (photo, img, js, fonts, css...) et de les appeler de mani√®re absolue.

1/ Modification du fichier composer.json

    "require" : {
        "symfony/asset": "^3.4"
    }

2/ Mise √† jour de l'app.

    <cmd>
    composer update (permet d'executer ce que l'on demande )


3/ Dossier Web (photo, css / js...)

    Boutique3/web/
        photo/ (√† recup√©rer du site en proc√©dural)
        css / ( √† cr√©er)
        js / ( √† cr√©er)

4/ Modification des vues.
    href="../../style.css"
    ->href="{{ asset('css/style.css') }}"

    href=""inscription.php"
     ->href="{{ path('inscription') }}"

     La fonction asset() de TWIG nous permet de charger une ressource (photo, css, js, fonts...)
     le chemin de asset sera absolue,idem pour path   

     La fonction path() de TWIG nous permet de cr√©er un lien vers une page (route).


     // liens dynamiques :

     src="../../photo/<?= $pdt['photo'] ?>"
     src="{{ asset('photo/' ~ pdt.photo ) }}"

     href="fiche_produit.php?id=<?= $pdt['id'] ?>"
     href={{ path('produit', {'id' : pdt.id }) }}"
     @Route("produit/{id}", name="produit")

     explication :
        produit --> nom de la route
        id -------> param√®tre dynamique de la route
        pdt.id---->valeur du param√®tre dynamique

autre exemple:
        href="boutique.php?categorie<?= $pdt['categorie'] ?>"
        href="{{path('categorie', { 'cat':cat.categorie}) }}"
        @Route("categorie/{cat}", name="categorie")

        explication :
        categorie --> nom de la route
        cat -------> param√®tre dynamique de la route
        pdt.categorie---->valeur du param√®tre dynamique




-----------------------------------------------------------
ETAPE 7 : Entit√©s 
-----------------------------------------------------------
Sommaire : 
1/ Doctrine ORM et le concept des Entit√© (Entity)
2/ Cr√©er Entit√© Produit
3/ Annotations
4/ Mettre √† jour la BDD
5/ G√©n√©rer les entit√©s en ligne de commande
6/ G√©n√©rer la BDD via les Entit√©s
7/ G√©n√©rer les entit√© depuis la BDD

1/ Doctrine ORM et le concept des Entit√© (Entity)

    -D'une certaine mani√®re, les entit√©s correspondent √† la partie model de notre MVC. C'est la relation avec la BDD, mais en PHP et non de SQL.
    Th√©oriquement, nous n'avons plus besoin du SQL

    - ORM : Objets Relation Mapping

    - Nous allons cr√©e nos entit√©s, sous forme de classes PHP (POPO : PLAIN Old Php Objects), qui vont permettre √† Doctrine de comprendre notre BDD et de la manipuler.

    Par exemple : Pour faire INSERT INTO produit

    $produit = new Produit;
    persist($produit);

     pour faire un  DELETE * FROM produit Where id 'produit' = id_produit
     remove($produit);

     la requete pour cr√©er un formulaire
     createForm($produit);

     ===> Pour que cel√† soit possible,il faut expliquer √† Doctrine quel relation il existe entre la BDD et nos Entity

2/ Cr√©er Entit√© Produit

 A. Cr√©er src/AppBundle/Entity
 B. Cr√©er le fichier src/AppBundle/Entity/Produit.php
 C. Cr√©er notre class Produit et nos propri√©t√©s et les getters et les setters 



3/ Annotation (mapping)

- Avec Doctrine ORM, on param√®tre le mapping via les annotations.

use Doctrine\ORM\Mapping as ORM

--> Voir le Fichier Entity/Produit.php

/!\ ATTENTION: les annotations pour L'ID (primary key ) sont plus longues.

Liens :

Basic mapping

https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/basic-mapping.html Association Mapping



4/ Mettre √† jour

<cmd>

    php bin/console doctrine:schema:update --dump-sql

    --> voir la requete php bin/console doctrine:schema:update --force

    --> executer les modifs en BDD

    ==> Permet aussi de cr√©er une BDD √† partir de nos entit√©s5/ G√©n√©rer les Entit√©s en ligne de CommandeA. on doit
    connecter notre App √† la BDD

    - app//config/parameters.yml

    - php bin/console doctrine:generate:entity

    AppBundle:Membre

    -> on suit les etapes.

    ====> cela a cr√©√© le fichier Entity/Membre.php en quelques lignes de commandes.6/ G√©n√©rer la BDD via les Entit√©s -on
    peut cr√©e la BDD, depuis les entit√©s d√©ja cod√©es

    <cmd>

        php bin/condole Doctrine:schema:update --force

        ---> cr√©er les tables dans la BDD . par contre il faut que la BDD existe d√©ja7/ G√©n√©rer les entit√©s depuis la
        BDD

        -on peut cr√©e la BDD, depuis les entit√©s depuis la BDD

        <cmd>

            php bin/condole doctrine:mapping:import AppBundle\Entity annotation --path=src/AppBundle/Entity ===> Cette
            commande nous a permis de generer les Entit√©s depuis les tables de la BDD .

            - Par contre celan'a ni g√©n√©r√© les repository, ni les getteurs ni les setteurs .

            <code>

        @ORM\Entity(repositoryClass="AppBundle\Repository\ProduitRepository")

        @ORM\Entity(repositoryClass="AppBundle\Repository\CommandeRepository")

        @ORM\Entity(repositoryClass="AppBundle\Repository\MembreRepository")

        @ORM\Entity(repositoryClass="AppBundle\Repository\DetailsCommandeRepository")    <cmd>

    php bin/condole doctrine:generate:entities AppBundle

    ==> cela nous cr√©e nos getter et nos setter et g√©n√©re les repository


-----------------------------------------------------------
ETAPE 8 : DOCTRINE

Sommaire : 

1/ Le service Doctrine
2/ Acc√©der au service doctrine depuis les controllers
3/ Requetes SELECT * FROM ...
4/ Requetes SELECT * FROM ... WHERE id =
5/ Requetes SELECT * FROM ... WHERE ... = ...
6/ Requestes INSERT / UPDATE
7/ Requetes DELETE 
8/ Create Query et Query query_builder
-----------------------------------------------------------
1/ Le service doctrine

        Doctrine fait 2 choses:

        1/ Doctrine ORM (Object Relation Mapping)
        Il permet de lier les tables de notre BDD √† nos entit√©s . On ne va pas manipuler la BDD, mais des objjets (la table Produit ---> Entity Produit)

        2/ Doctrine DBAL (DataBase Abstract Layer)
        Le BDAL c'est une couche qui passe au-dessus de PDO. A partir de maintenant, on ne fait plus de requ√™te SQL, mais on va manipuler du PHP.

        - En r√©sum√© le DBAL va nous permettre de faire des SELECT, INSERT, UPDATE, DELETE, non pas via du SQL,mais via des fonctions PHP. On parle de DQL (Doctrine Query Language)

        ----> NOUS NE FERONS PLUS DE SQL (ou presque)

2/ Acc√©der au serive doctrine depuis les controllers

    A. Il faut pouvoir manipuler les entit√©s dont on a besoin.
    <code>
        use AppBundle\Entity\Produit;
    
    B. Acc√©der au repository dans un controller : 
    <code>
    $repo = $this -> getDoctrine() ->getRepository(Produit::Class);

    C. Acc√©der au Manager (qui peut faire des requ√™te sur toutes les tables)
    $em = $this ->getDoctrine() -> getManager();


3/ REQUETES SELECT * FROM 

    Depuis le repository :
    <code>
    $repo = $this ->getDoctrine() -> getRepository(Produit::Class);
    $produits = $repo ->findAll();


4/ Requetes SELECT * FROM ... WHERE id =

    Depuis le repository :
    <code>
    $repo = $this ->getDoctrine() -> getRepository(Produit::Class);
    $produits = $repo ->find($id);

    Depuis le Manager :
    <code>
    $em = $this ->getDoctrine() -> getManager();
    $produit = $em -> find(Produit::class, $id);


5/ Requetes SELECT * FROM ... WHERE ... = ...

    La fonction findBy () va nous permettre de r√©cup√©rer des donn√©es de mani√®re plis cibl√©e.
    <code>
    $repo = $^this ->getDoctrine() ->getRepositoryProduit::Class;
    $produit = $repo ->findBy(array('categorie') => $cat));
    $produit = $repo ->findBy(array('taille') => '1'));

    $produit = $repo ->findBy(array(
        'categorie' => 'tee-shirt',
        'taille' => '1'
    ));

    SELECT * FROM produit WHERE taille = '1' AND categorie = 'tee-shirt'

    $produit = $repo -> findBy(['couleur' => 'rouge'], ['prix' => 'DESC'], 0, 10);
    SELECT * FROM produit WHERE couleur = 'rouge' ORDER BY prix DESC LIMIT 0,10

    $produit = $repo ->findOneBy(array('taille' => '1'));
    SELECT * FROM produit WHERE taille = '1' LIMIT 0,1


6/ Requestes INSERT / UPDATE

    - Avec doctrine on manipule des Objet (Entit√©)

    -> Enregistrement :
        - On cr√©e un objet vide.
        - on hydrate l'objet (normalement via un formulaire)
        - on persist et on flush

    <code>  
    $produit = new Produit;
    $produit -> setTitre-('dsqqsdqd')
    $produit -> setReference-('dsqqsdqd')
    ...
    $em -> persist($produit);
    $em -> flish();

    ->Modification :  
        
        - Pour update une entr√©e, c'est la m√™me chose que pour ADD, √† ceci pr√®s que l'objet n'est pas vide √† la base.
          On doit donc r√©cup√©rer l'objet √† modifier avec la fonction find()
          
7/ Requetes DELETE
        - Avec doctrine on manipule des Objets (Entit√©) dp,c p, va r√©ci^√©rer d'abord l'ojbet √† supprim√© avec la fonction find().

        <code> 
        $em -> remove($produit);
        $em -> flush();


8/ Create Query et Query Builder (faire du sql avec create query  ou ne pas en faire avec query builder)


EXERCICE : 

A faire : La gestion des produits : 

        AdminController 
        -> /admin/produit/

        $produits qui va r√©cup√©rer tous les produits du site

        ->list_produit.html.twig

        ->tableau avec tous les infos des produits
        ->action : modifier/supprimer


SELECT DISTINCT (categorie FROM produit)
            
    Pour effectuer des requ√™te sp√©cifiques, nous avons 2 possibilit√©s : 

        - Create Query (SQL)
        - Query Builder (PHP)

    ==> VOIR ProduitRepository

    /!\ Dans l'objectif de "factoriser" notre code, nous cr√©ons nos requ√™tes sp√©cifiques dans le Repository, afin de les utiliser de mani√®re simple dans les controller.
    
    ==> Voir le ProduitController, route / categorie/ et la fonction GetAllCategories() d√©clar√©e dans le ProduitRepository.

    Liens :
    
    Query Builder : 

    https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html

    Create Query : 

    https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html

-----------------------------------------------------------
ETAPE 9 : Les formulaires

Sommaire :
1/ Le fonctionnement des formulaires 
2/ G√©n√©rer les formulaire 
3/ R√©cup√©rer les donn√©es du formulaire 
4/ Personnaliser un formulaire avec Bootstrap 
5/ Update un enregistrement 
6/ Validation des donn√©es 
7/ Champs file

1/ Le fonctionnement des formulaires

-De la m√™me mani√®re qu'on ne manipule pas des enregistrement en BDD, mais bien des objets (Entity) , chaque formulaire va √™tre li√©e a une entit√©.

-Ainsi un formulaire est li√© √† un objet....

Inscription ---------->objet Membre
Ajout de produit ----->objet Produit
Modif de produit ----->objet Produit

Un formulaire est g√©n√©rer gr√†ce √† une classe( Type --> ProduitType)
Chaque champs d'un formulaire correspond √† une classe, service de Symfony.Cela va permetttre de g√©n√©rer tous les contr√¥les sur les formulaires

2/ G√©n√©rer les formulaires 

<cmd>
    php bin/console generate:doctrine:form AppBundle:Produit

-----> Cela cr√©er un dossier Form dans notre Bundle , et un fichier ProduitType.php, qui contient la construction du formulaire.



3/ R√©cup√©rer les donn√©es du formulaire

    A. G√©n√©rer le form dans la route

        <code>
        use AppBundle\Form\ProduitType 
        $form = $this -> createForm(ProduitType::class, $produit);

    B. Afficher la vue du formulaire dans la vue
        
        - On envoie le formualire √† la vue via les params 
            <code>
        $params = array('produitForm' => $form -> createView()) 

        - On affiche le formulaire : 
            <code>
            {{form(produitForm) }} -->affiche tout le formulaire 
            ---
            {{ form_row(produitForm.reference) }} --> affiche un champs  (label, champs, errors)
            ----
            {{ form_label(produitForm.reference) }} --> affiche le label
            {{ form_widget(produitForm.reference) }} --> affiche le champs
            {{ form_errors(produitForm.reference) }} --> affiche les erreurs 

            /!\ Si on affiche les champs un par un , il ne faut pas oublier : 
            {{ form_start (produitForm) }}
            {{ form_end (produitForm) }}
            
    C. R√©cup√©rer les donn√©es saisies 

    <code>
    $form -> handleRequest $request); 
    /!\ cette ligne est importante pour pouvoir r√©cup√©rer les donn√©es en POST !!


    D. Checker la validit√© du form et traiter les donn√©es 

    <code>
    if($form -> isSubmitted() && form -> isValid()){
        // persist 
        // flush 
        // message de validation 
        // redirection 
    }


4/ Personnaliser un formulaire avec Bootstrap

    <code>app/config/config/.yml 
    twig:
        form_themes: 
            - 'bootstrap_4_layout.html.twig' 


5/ Update un enregistrement

    Pour update un enregistrement avec le syst√®me des formulaires sur SF rien de plus simple. 
    Lorsqu'on cr√©er le formulaire dans la route, on pr√©cisera un objet d√©ja existant (cf route admin/admin/produit/update/{id}).


    ---> On dit qu'on hydrate le formulaire.


6/ Validation des donn√©es

Exercice

A faire: Inscription (page inscription)

1/ Entity Membre
2/ Controller : MembreController ----> Route "/inscription"
3/ Formulaire (MembreType) --> console 
4/ Route : Cr√©er le formulaire et sa vue 
5/ La vue : Afficher le formulaire 
6/ Route : R√©cup√©rer les infos du formulaire et enregistrer le membre .

Attention : Etant donn√©e que le champs Statut existe dans notre BDD, le formulaire va √™tre cr√©er avec un champs Statut, hors ce n'est pas au membre de choisir son statut 


    - De base, le formulaire est g√©n√©r√© par SF de mani√®re basique. Pour g√©rer nous-m√™me les contraintes et la s√©curit√©; cel√† se passe dans le fichier ProduitType.php, et on utilise 'constraints' pour d√©finir les contraintes li√©es au formulaire.

    -> cf ProduitType.php


7/ Champs file

        Pour la gestion des photos, il faut : 
        
        1/ Enregistrer le nom de la photo dans la BDD 
        2/ Enregistrer la photo (data) sur le serveur. 

        ==> CF fonction uploadFile() dans l'entity Produit

/!\ Dans notre formulaire d'ajout de produit, il n'est plus n√©c√©ssaire d'avoir le champs photo (TEXT),mais bien un champs file (FILE) qui va r√©cup√©rer les infos de la photo upload√©e.

Pour aller plus loin avec les formulaire et Symfony :

https://symfony.com/doc/current/reference/forms/types.html

--------------------------------------------------
ETAPE 10 : Validation des donn√©es :
--------------------------------------------------
Pour aller plus loin avec la validation des donn√©es et Symfony : (assert et contraintes)
https://symfony.com/doc/current/validation.html

-----------------------------------------------------------
ETAPE 11 : ASSOCIATION MAPPING
----------------------------------------------------------
Sommaire :
1/ Le concept
2/ La Documentation de Doctrine
3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande
-----------------------------

1/ Avec Doctrine, on a pris l'habitude de travailler avec des objets (Entity) correspondant aux enregistrements dans la
BDD (Mapping).

L'association Mapping nous permet de travailler avec des objets dans des objets. Exemple : Un membre peut avoir
plusieurs commandes, dans ce cas, dans un objet Membre nous avons un array compos√© d'objets commande. Une commande
appartient √† UN membre, dans ce cas dans un objet Commande nous avons un objet membre.

Gr√¢ce √† ce fonctionnement il est plus n√©cessaire de faire des requ√™tes de jointure, lorsqu'on r√©cup√®re un objet, on
r√©cup√®re tous les objets li√©s.

2/
https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#association-mapping


3/ mise en place de l'association Mapping (OneToMany) pour Membre -> Commande

-> Entity Membre
-> Entity Commande


-> Dans la vue list_commande.html.twig, on utilise {{ c.membre.prenom }} pour acc√©der aux infos du membre qui a pass√© la
commande.


-----------------------------------------------------------------

ETAPE 12 : SECURITE ET UTILISATEURS 
-----------------------------------------------------------------
Sommaire : 
1/ Niveau de s√©curit√© 
2/ Fichier de s√©curit√© 
3/ Creation des routes 
4/ Classe Membre (extends UserInterface) 
5/ Layout 



1/ Niveau de s√©curit√©

    - De base Symfony va consid√©rer un visiteur lambda comme un anonyme.

    - Ensuite on va d√©finir des niveaux de s√©curit√© pour les utilisateurs connect√© :
        - ROLE_USER
        - ROLE_ADMIN
        - ROLE_SUPER_ADMIN

        -SF a un syst√®me de pare-feu : 

        - On d√©finit les routes que les ROLE peuvent emprunter.

        -> Si un user anonyme --> homepage = OK 
        -> Si un user anonyme -->profil = pas OK -> connexion -> profil
        -> Si un user connect√© --> profil = OK
        -> Si un user connect√© --> admin/produit = pas OK --> page erreur (404) 

        En fonction du visiteur et de la ressources demand√©e, on peut param√©trer une r√©action

2/ Fichier de s√©curit√© 

<code>app/config/security.yml

php bin/console doctrine:schema:update --dump-sql

 √† √©crire sert a modifi√© la base de donn√©e puis 

$ php bin/console doctrine:schema:update --force


Dans membre.php,on a du rajouter 2 function obligatoire 'roles' et 'salt'

<code>app/config/security.yml
	
	On d√©finie plusieurs choses : 
	- encoders (la mani√®re dont les password seront encod√©s)
	- provider (quelle ressource va servir d'utilisateur : MembreEntity, le login: username)
	- Hierarchie : La pyramide des droits
	- les routes form_login et logout (voir le point suivant)
	- Access control : qui a le droit √† quoi


	/!\ Attention le YAML est tr√®s sensible aux indentations et aux espaces. 
	



3/ Creation des routes
	
	form_login: 
		login_path: connexion (page de connexion)
		
		check_path: connexion_check (Page de checking de login/password, on doit juste la cr√©√©e, et la mettre dans l'attribut action de notre formulaire de connexion)
		
		default_target_path: homepage (La page par d√©faut sur laquelle on est dirig√© une fois connect√©. Sinon le parefeu prend le dessus)

	logout:
		path: deconnexion (La route de deconnexion. Doit exister mais est vide)
		target: homepage (page de destination, lorsqu'on se d√©connecte). 
		


4/ Classe Membre (extends UserInterface)
	
	- A partir de maintenant la classe Membre doit implements l'interface UserInterface
		
		
	--> username (getter/setter)
	--> password (getter/setter)
	--> roles (getter/setter) /!\ roles est un array 
	--> salt (getter/setter)
	
	/!\ Attention lors de l'inscription, il faut penser √† d√©finir un role_user par d√©faut. 
	
	--> public function eraseCredentials() : fonction obligatoire pour que SF prenne la main. 
	
	--> getRoles() et setRoles() au pluriel obligatoirement. 


5/ Layout

	Dans les vues on fait la distinction entre le niveau d'acces des utilisateur avec : 
		
	{{ if is_granted('IS_AUTHENTICATED_FULLY') }}  : tout le monde (sauf anonyme)
	{{ if is_granted('ROLE_USER') }}  : tous les users
	{{ if is_granted('ROLE_ADMIN') }}  : tous les admin
	
		
===> Le salage (cf salt.php) c'est l'id√©e de rendre un MDP quasiment inviolable en ajoutant au MDP soit une cha√Æne de caract√®re que seul le d√©veloppeur connait (petit site, petite structure), ou alors une cha√Æne al√©atoire pour chaque user... Ensuite pour la connexion, on r√©cup√®re le salage, pour reconstituer le MDP complet.

ETAPE 13 : Symfony 4
Sommaire :
1/ Installation
2/ L'architecture
3/ Lancement de l'app
4/ Le maker
5/ Flex
-------------------


1/ installation :
composer create-project symfony/website-skeleton Boutique 4

2/ L'architecture

- app a disparu ----> config
- src/AppBundle a disparu ----> BundleLess sans Bundle mais toujours dans le namespace App\
- src/Resources/ View a disparu ---> templates

Le dossier templates prendra toutes les vues (Produit/ Admin/ Membres/ Bases) ainsi que le layout.html.twig

web/ a disparu (app_dev.php, app.php, JS/CSS/Photo) ----> public (index.php, JS/CSS/Photo etc...)

.env : Notre config (notamment les infos de connexion √† la bdd

3/ Lancement de l'app

<cmd>
    php bin/console server:start
    ou alors
    php bin/console server:run


    4/ Le maker :

    - Cr√©ation des Entit√©s :
    php bin/console make:entity

    ou depuis la BDD :
    php bin/console doctrine:mapping:import "App\Entity" annotation --path=src/Entity


    - Mise √† jours des entit√©s :
    php bin/console make:Entity --regenerate


    - Cr√©er les controller :
    php bin/console make:controller
    ProduitController
    MembreController
    CommandeController
    BaseController
    AdminController

    - Cr√©er les CRUD :
    - pre-requis : Copier/coller les entit√©s

    copier le dossier boutique3/src/AppBundle/Entity
    le coller dans le dossier boutique4/src/


    <cmd>
        php bin/console make:crud
        Membre
        Commande
        Produit


        - Cr√©er l'entit√© Membre :
        <cmd>
            php bin/console make:user



            Bundle :

            - FOSUserBundle
            - easyAdmin

            Flex :

            Symfony Flex : la nouvelle fa√ßon de d√©velopper avec Symfony
            Les versions de Symfony 3.4 et 4.0 viennent tout juste de sortir et avec elles vient une nouvelle fa√ßon de
            d√©velopper des applications Symfony. D√Ætes adieu √† la Standard Edition et bonjour aux tout nouveaux
            symfony/skeleton, Symfony Flex et les recettes qui vont avec.

            Vous avez dit Flex ?
            D‚Äôun point de vue technique, Symfony Flex est juste un plugin Composer. Il se branche sur les √©v√©nements
            Composer d√®s lors que vous lancez une commande qui installe, met √† jour ou supprime un paquet PHP ou bundle
            Symfony. Son but ? Automatiser l‚Äôinstallation et la suppression de vos d√©pendances en fournissant une
            configuration par d√©faut sans avoir √† aller lire la doc pour trouver quelle configuration √©crire, quelles
            routes charger ou autre t√¢che r√©barbative √† effectuer. Et d√®s Symfony 4.0, Flex sera le moyen par d√©faut
            pour d√©velopper une application Symfony.

            Il para√Æt qu‚Äôun bon exemple vaut mieux qu‚Äôun long discours. Alors imaginons que vous ayez une application
            existante en Symfony 3.3 (parce que vous √™tes un dev cool et avez effectu√© les migrations vers les derni√®res
            versions de Symfony au fur et √† mesure üí™). Vous voulez y ajouter une API en installant api-platform. Vous
            allez donc effectuer les t√¢ches suivantes :


            Sources : https://afsy.fr/avent/2017/08-symfony-flex-la-nouvelle-facon-de-developper-avec-symfony


            WebPack Encore :
            https://symfony.com/doc/current/frontend.html